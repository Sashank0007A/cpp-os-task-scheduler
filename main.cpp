#include <iostream>#include <vector>#include <iomanip>#include <fstream>  using namespace std;// Define the Process structurestruct Process {    int pid;    int arrivalTime;    int burstTime;    int priority;        int startTime;    int completionTime;    int turnaroundTime;    int waitingTime;    Process(int _pid, int _arrival, int _burst, int _priority = 0)        : pid(_pid), arrivalTime(_arrival), burstTime(_burst), priority(_priority),          startTime(0), completionTime(0), turnaroundTime(0), waitingTime(0) {}};void fcfsScheduling(vector<Process>& processes) {    sort(processes.begin(), processes.end(), [](const Process& a, const Process& b) {        return a.arrivalTime < b.arrivalTime;    });    int currentTime = 0;    float totalTAT = 0, totalWT = 0;    cout << "\n\n=== FCFS Scheduling ===\n";    for (auto& p : processes) {        p.startTime = max(currentTime, p.arrivalTime);        p.completionTime = p.startTime + p.burstTime;        p.turnaroundTime = p.completionTime - p.arrivalTime;        p.waitingTime = p.turnaroundTime - p.burstTime;        currentTime = p.completionTime;        totalTAT += p.turnaroundTime;        totalWT += p.waitingTime;    }    // Display Results    cout << "\nFCFS Schedule:\n";    cout << setw(5) << "PID" << setw(12) << "AT" << setw(10) << "BT"         << setw(10) << "ST" << setw(10) << "CT"         << setw(10) << "TAT" << setw(10) << "WT" << endl;    for (const auto& p : processes) {        cout << setw(5) << p.pid << setw(12) << p.arrivalTime             << setw(10) << p.burstTime << setw(10) << p.startTime             << setw(10) << p.completionTime << setw(10) << p.turnaroundTime             << setw(10) << p.waitingTime << endl;    }    cout << fixed << setprecision(2);    cout << "\nAverage Turnaround Time: " << totalTAT / processes.size() << endl;    cout << "Average Waiting Time   : " << totalWT / processes.size() << endl;}void sjfScheduling(vector<Process> processes) {    cout << "\n\n=== SJF (Non-Preemptive) Scheduling ===\n";    int n = processes.size();    int completed = 0, currentTime = 0;    float totalTAT = 0, totalWT = 0;    vector<bool> isDone(n, false);    while (completed < n) {        int idx = -1;        int minBT = INT_MAX;        for (int i = 0; i < n; ++i) {            if (!isDone[i] && processes[i].arrivalTime <= currentTime) {                if (processes[i].burstTime < minBT ||                    (processes[i].burstTime == minBT && processes[i].arrivalTime < processes[idx].arrivalTime)) {                    minBT = processes[i].burstTime;                    idx = i;                }            }        }        if (idx != -1) {            processes[idx].startTime = currentTime;            processes[idx].completionTime = currentTime + processes[idx].burstTime;            processes[idx].turnaroundTime = processes[idx].completionTime - processes[idx].arrivalTime;            processes[idx].waitingTime = processes[idx].turnaroundTime - processes[idx].burstTime;            currentTime = processes[idx].completionTime;            isDone[idx] = true;            completed++;            totalTAT += processes[idx].turnaroundTime;            totalWT += processes[idx].waitingTime;        } else {            currentTime++;  // CPU is idle        }    }    // Output    cout << setw(5) << "PID" << setw(12) << "AT" << setw(10) << "BT"         << setw(10) << "ST" << setw(10) << "CT"         << setw(10) << "TAT" << setw(10) << "WT" << endl;    for (const auto& p : processes) {        cout << setw(5) << p.pid << setw(12) << p.arrivalTime             << setw(10) << p.burstTime << setw(10) << p.startTime             << setw(10) << p.completionTime << setw(10) << p.turnaroundTime             << setw(10) << p.waitingTime << endl;    }    cout << fixed << setprecision(2);    cout << "\nAverage Turnaround Time: " << totalTAT / n << endl;    cout << "Average Waiting Time   : " << totalWT / n << endl;}void priorityScheduling(vector<Process> processes) {    cout << "\n\n=== Priority Scheduling (Non-Preemptive) ===\n";    int n = processes.size();    int completed = 0, currentTime = 0;    float totalTAT = 0, totalWT = 0;    vector<bool> isDone(n, false);    while (completed < n) {        int idx = -1;        int highestPriority = INT_MAX;        for (int i = 0; i < n; ++i) {            if (!isDone[i] && processes[i].arrivalTime <= currentTime) {                if (processes[i].priority < highestPriority ||                   (processes[i].priority == highestPriority && processes[i].arrivalTime < processes[idx].arrivalTime)) {                    highestPriority = processes[i].priority;                    idx = i;                }            }        }        if (idx != -1) {            processes[idx].startTime = currentTime;            processes[idx].completionTime = currentTime + processes[idx].burstTime;            processes[idx].turnaroundTime = processes[idx].completionTime - processes[idx].arrivalTime;            processes[idx].waitingTime = processes[idx].turnaroundTime - processes[idx].burstTime;            currentTime = processes[idx].completionTime;            isDone[idx] = true;            completed++;            totalTAT += processes[idx].turnaroundTime;            totalWT += processes[idx].waitingTime;        } else {            currentTime++; // CPU is idle        }    }    // Display the results    cout << setw(5) << "PID" << setw(12) << "AT" << setw(10) << "BT"         << setw(10) << "PR" << setw(10) << "ST"         << setw(10) << "CT" << setw(10) << "TAT"         << setw(10) << "WT" << endl;    for (const auto& p : processes) {        cout << setw(5) << p.pid << setw(12) << p.arrivalTime             << setw(10) << p.burstTime << setw(10) << p.priority             << setw(10) << p.startTime << setw(10) << p.completionTime             << setw(10) << p.turnaroundTime << setw(10) << p.waitingTime << endl;    }    cout << fixed << setprecision(2);    cout << "\nAverage Turnaround Time: " << totalTAT / n << endl;    cout << "Average Waiting Time   : " << totalWT / n << endl;}void roundRobinScheduling(vector<Process> processes, int quantum) {    cout << "\n\n=== Round Robin Scheduling (Time Quantum = " << quantum << ") ===\n";    int n = processes.size();    queue<int> q;    vector<int> remainingBT(n);    vector<bool> inQueue(n, false);    int currentTime = 0, completed = 0;    float totalTAT = 0, totalWT = 0;    for (int i = 0; i < n; ++i)        remainingBT[i] = processes[i].burstTime;    // sort by arrival    sort(processes.begin(), processes.end(), [](const Process& a, const Process& b) {        return a.arrivalTime < b.arrivalTime;    });    q.push(0);    inQueue[0] = true;    currentTime = processes[0].arrivalTime;    while (!q.empty()) {        int i = q.front(); q.pop();        if (processes[i].startTime == 0 && remainingBT[i] != processes[i].burstTime)            processes[i].startTime = currentTime;        if (remainingBT[i] == processes[i].burstTime)            processes[i].startTime = max(currentTime, processes[i].arrivalTime);        int execTime = min(quantum, remainingBT[i]);        currentTime = max(currentTime, processes[i].arrivalTime) + execTime;        remainingBT[i] -= execTime;        // check newly arrived processes        for (int j = 0; j < n; ++j) {            if (!inQueue[j] && processes[j].arrivalTime <= currentTime && remainingBT[j] > 0) {                q.push(j);                inQueue[j] = true;            }        }        if (remainingBT[i] > 0) {            q.push(i);        } else {            processes[i].completionTime = currentTime;            processes[i].turnaroundTime = processes[i].completionTime - processes[i].arrivalTime;            processes[i].waitingTime = processes[i].turnaroundTime - processes[i].burstTime;            totalTAT += processes[i].turnaroundTime;            totalWT += processes[i].waitingTime;            completed++;        }        if (q.empty()) {            for (int j = 0; j < n; ++j) {                if (!inQueue[j] && remainingBT[j] > 0) {                    q.push(j);                    inQueue[j] = true;                    break;                }            }        }    }    // Display the results    cout << setw(5) << "PID" << setw(12) << "AT" << setw(10) << "BT"         << setw(10) << "ST" << setw(10) << "CT"         << setw(10) << "TAT" << setw(10) << "WT" << endl;    for (const auto& p : processes) {        cout << setw(5) << p.pid << setw(12) << p.arrivalTime             << setw(10) << p.burstTime << setw(10) << p.startTime             << setw(10) << p.completionTime << setw(10) << p.turnaroundTime             << setw(10) << p.waitingTime << endl;    }    cout << fixed << setprecision(2);    cout << "\nAverage Turnaround Time: " << totalTAT / n << endl;    cout << "Average Waiting Time   : " << totalWT / n << endl;}// Function to display process tablevoid displayProcesses(const vector<Process>& processes) {    cout << "\nPROCESS TABLE:\n";    cout << setw(10) << "PID"          << setw(15) << "Arrival Time"          << setw(15) << "Burst Time"         << setw(10) << "Priority" << endl;    for (const auto& p : processes) {        cout << setw(10) << p.pid             << setw(15) << p.arrivalTime             << setw(15) << p.burstTime             << setw(10) << p.priority << endl;    }}int main() {    cout << "====== OS CPU Task Scheduler (C++) ======\n";    ifstream fin("input.txt");    if (!fin) {        cerr << "Error: Could not open input.txt" << endl;        return 1;    }    int n;    fin >> n;    vector<Process> processes;    for (int i = 0; i < n; ++i) {        int at, bt, pr;        fin >> at >> bt >> pr;        processes.emplace_back(i + 1, at, bt, pr);    }    displayProcesses(processes);    fcfsScheduling(processes);    sjfScheduling(processes);    priorityScheduling(processes);    roundRobinScheduling(processes, 3);              return 0;}