#ifndef SCHEDULER_H#define SCHEDULER_H#include <iostream>#include <iomanip>#include <set>#include <map>#include <vector>#include <string>#include <SFML/Graphics.hpp>#include <algorithm>#include <queue>#include <fstream>struct Process {    std::string pid;    int arrivalTime;    int burstTime;    int priority;};struct GanttBlock {    std::string pid;    int startTime;    int burstTime;    sf::Color color;};// Utility to assign color per PIDsf::Color getColorForPID(const std::string& pid) {    static std::vector<sf::Color> palette = {        sf::Color::Red, sf::Color::Green, sf::Color::Blue,        sf::Color(220, 0, 0), sf::Color::Magenta, sf::Color::Cyan,        sf::Color(255, 165, 0), sf::Color(128, 0, 128)    };    int num = std::stoi(pid.substr(1)) % palette.size();    return palette[num];}// Parse input.txt and return processesstd::vector<Process> parseInput(const std::string& filename) {    std::ifstream fin(filename);    std::vector<Process> processes;    int n;    fin >> n;    for (int i = 0; i < n; ++i) {        int at, bt, pr;        fin >> at >> bt >> pr;        processes.push_back({"P" + std::to_string(i + 1), at, bt, pr});    }    return processes;}std::vector<GanttBlock> fcfsSchedule(std::vector<Process> processes) {    std::sort(processes.begin(), processes.end(), [](auto& a, auto& b) {        return a.arrivalTime < b.arrivalTime;    });    std::vector<GanttBlock> chart;    int currentTime = 0;    for (const auto& p : processes) {        int st = std::max(currentTime, p.arrivalTime);        chart.push_back({p.pid, st, p.burstTime, getColorForPID(p.pid)});        currentTime = st + p.burstTime;    }    return chart;}std::vector<GanttBlock> sjfSchedule(std::vector<Process> processes) {    int n = processes.size(), completed = 0, currentTime = 0;    std::vector<bool> done(n, false);    std::vector<GanttBlock> chart;    while (completed < n) {        int idx = -1, minBT = 1e9;        for (int i = 0; i < n; ++i) {            if (!done[i] && processes[i].arrivalTime <= currentTime && processes[i].burstTime < minBT) {                minBT = processes[i].burstTime;                idx = i;            }        }        if (idx == -1) {            currentTime++;            continue;        }        chart.push_back({processes[idx].pid, currentTime, processes[idx].burstTime, getColorForPID(processes[idx].pid)});        currentTime += processes[idx].burstTime;        done[idx] = true;        completed++;    }    return chart;}std::vector<GanttBlock> prioritySchedule(std::vector<Process> processes) {    int n = processes.size(), completed = 0, currentTime = 0;    std::vector<bool> done(n, false);    std::vector<GanttBlock> chart;    while (completed < n) {        int idx = -1, bestPrio = 1e9;        for (int i = 0; i < n; ++i) {            if (!done[i] && processes[i].arrivalTime <= currentTime &&                processes[i].priority < bestPrio) {                bestPrio = processes[i].priority;                idx = i;            }        }        if (idx == -1) {            currentTime++;            continue;        }        chart.push_back({processes[idx].pid, currentTime, processes[idx].burstTime, getColorForPID(processes[idx].pid)});        currentTime += processes[idx].burstTime;        done[idx] = true;        completed++;    }    return chart;}std::vector<GanttBlock> roundRobinSchedule(std::vector<Process> processes, int quantum) {    int n = processes.size(), currentTime = 0, completed = 0;    std::vector<int> remBT(n);    for (int i = 0; i < n; ++i) remBT[i] = processes[i].burstTime;    std::queue<int> q;    std::vector<bool> inQueue(n, false);    std::vector<GanttBlock> chart;    auto cmpArrival = [](const Process& a, const Process& b) {        return a.arrivalTime < b.arrivalTime;    };    std::sort(processes.begin(), processes.end(), cmpArrival);    q.push(0);    inQueue[0] = true;    currentTime = processes[0].arrivalTime;    while (completed < n) {        int i = q.front(); q.pop();        int st = std::max(currentTime, processes[i].arrivalTime);        int execTime = std::min(quantum, remBT[i]);        chart.push_back({processes[i].pid, st, execTime, getColorForPID(processes[i].pid)});        remBT[i] -= execTime;        currentTime = st + execTime;        for (int j = 0; j < n; ++j) {            if (!inQueue[j] && processes[j].arrivalTime <= currentTime && remBT[j] > 0) {                q.push(j);                inQueue[j] = true;            }        }        if (remBT[i] > 0)            q.push(i);        else            completed++;    }    return chart;}std::pair<float, float> calculateMetrics(const std::vector<GanttBlock>& chart, const std::vector<Process>& original) {    std::map<std::string, int> startTime, finishTime, burstTime, arrivalTime;    for (const auto& p : original) {        burstTime[p.pid] = p.burstTime;        arrivalTime[p.pid] = p.arrivalTime;    }    for (const auto& block : chart) {        if (!startTime.count(block.pid))            startTime[block.pid] = block.startTime;        finishTime[block.pid] = block.startTime + block.burstTime;    }    float totalTAT = 0, totalWT = 0;    int n = original.size();    for (const auto& p : original) {        int tat = finishTime[p.pid] - arrivalTime[p.pid];        int wt = tat - burstTime[p.pid];        totalTAT += tat;        totalWT += wt;    }    return {totalTAT / n, totalWT / n};}void printScheduleTable(const std::string& algoName, const std::vector<GanttBlock>& chart, const std::vector<Process>& processes, bool hasPriority = false) {    std::map<std::string, int> AT, BT, PR, ST, CT;    std::set<std::string> printed;    for (const auto& p : processes) {        AT[p.pid] = p.arrivalTime;        BT[p.pid] = p.burstTime;        if (hasPriority) PR[p.pid] = p.priority;    }    for (const auto& block : chart) {        if (!printed.count(block.pid)) {            ST[block.pid] = block.startTime;            printed.insert(block.pid);        }        CT[block.pid] = block.startTime + block.burstTime;    }    std::cout << "\n=== " << algoName << " ===\n";    if (hasPriority)        std::cout << "  PID          AT        BT        PR        ST        CT       TAT        WT\n";    else        std::cout << "  PID          AT        BT        ST        CT       TAT        WT\n";    float totalTAT = 0, totalWT = 0;    for (const auto& p : processes) {        int tat = CT[p.pid] - AT[p.pid];        int wt = tat - BT[p.pid];        totalTAT += tat;        totalWT += wt;        if (hasPriority)            std::cout << std::setw(5) << p.pid << std::setw(12) << AT[p.pid] << std::setw(10) << BT[p.pid]                      << std::setw(10) << PR[p.pid] << std::setw(10) << ST[p.pid]                      << std::setw(10) << CT[p.pid] << std::setw(10) << tat << std::setw(10) << wt << "\n";        else            std::cout << std::setw(5) << p.pid << std::setw(12) << AT[p.pid] << std::setw(10) << BT[p.pid]                      << std::setw(10) << ST[p.pid] << std::setw(10) << CT[p.pid]                      << std::setw(10) << tat << std::setw(10) << wt << "\n";    }    int n = processes.size();    std::cout << "\nAverage Turnaround Time: " << std::fixed << std::setprecision(2) << (totalTAT / n) << "\n";    std::cout << "Average Waiting Time   : " << std::fixed << std::setprecision(2) << (totalWT / n) << "\n\n";}#endif